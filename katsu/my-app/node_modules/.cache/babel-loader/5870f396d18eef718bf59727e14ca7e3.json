{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _editModes = require(\"@nebula.gl/edit-modes\");\n\nvar _constants = require(\"../constants\");\n\nvar _baseMode = _interopRequireDefault(require(\"./base-mode\"));\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nvar EditingMode = /*#__PURE__*/function (_BaseMode) {\n  _inherits(EditingMode, _BaseMode);\n\n  var _super = _createSuper(EditingMode);\n\n  function EditingMode() {\n    _classCallCheck(this, EditingMode);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(EditingMode, [{\n    key: \"handleClick\",\n    value: function handleClick(event, props) {\n      var picked = event.picks && event.picks[0];\n      var selectedFeatureIndex = props.selectedIndexes && props.selectedIndexes[0]; // @ts-ignore\n\n      if (!picked || !picked.object || picked.featureIndex !== selectedFeatureIndex) {\n        return;\n      } // @ts-ignore\n\n\n      var objectType = picked.type,\n          featureIndex = picked.featureIndex,\n          index = picked.index;\n      var feature = this.getSelectedFeature(props, featureIndex);\n\n      if (feature && (feature.geometry.type === _constants.GEOJSON_TYPE.POLYGON || feature.geometry.type === _constants.GEOJSON_TYPE.LINE_STRING) && objectType === _constants.ELEMENT_TYPE.SEGMENT) {\n        var coordinates = (0, _utils.getFeatureCoordinates)(feature);\n\n        if (!coordinates) {\n          return;\n        } // @ts-ignore\n\n\n        var insertIndex = (index + 1) % coordinates.length;\n        var positionIndexes = feature.geometry.type === _constants.SHAPE.POLYGON ? [0, insertIndex] : [insertIndex];\n\n        var insertMapCoords = this._getPointOnSegment(feature, picked, event.mapCoords);\n\n        var updatedData = new _editModes.ImmutableFeatureCollection(props.data) // @ts-ignore\n        .addPosition(featureIndex, positionIndexes, insertMapCoords).getObject();\n        props.onEdit({\n          editType: _constants.EDIT_TYPE.ADD_POSITION,\n          updatedData: updatedData,\n          editContext: [{\n            featureIndex: featureIndex,\n            editHandleIndex: insertIndex,\n            // @ts-ignore\n            screenCoords: props.viewport && props.viewport.project(insertMapCoords),\n            mapCoords: insertMapCoords\n          }]\n        });\n      }\n    }\n  }, {\n    key: \"handleStopDragging\",\n    value: function handleStopDragging(event, props) {\n      // replace point\n      var picked = event.picks && event.picks[0]; // @ts-ignore\n\n      if (!picked || !picked.Object || !(0, _utils.isNumeric)(picked.featureIndex)) {\n        return;\n      }\n\n      var pickedObject = picked.object;\n\n      switch (pickedObject.type) {\n        case _constants.ELEMENT_TYPE.FEATURE:\n        case _constants.ELEMENT_TYPE.FILL:\n        case _constants.ELEMENT_TYPE.EDIT_HANDLE:\n          this._handleDragging(event, props);\n\n          break;\n\n        default:\n      }\n    }\n  }, {\n    key: \"_handleDragging\",\n    value: function _handleDragging(event, props) {\n      var onEdit = props.onEdit; // @ts-ignore\n\n      var selectedFeature = this.getSelectedFeature(props); // nothing clicked\n      // @ts-ignore\n\n      var isDragging = event.isDragging,\n          pointerDownPicks = event.pointerDownPicks,\n          screenCoords = event.screenCoords;\n      var lastPointerMoveEvent = props.lastPointerMoveEvent;\n      var clicked = pointerDownPicks && pointerDownPicks[0]; // @ts-ignore\n\n      if (!clicked || !clicked.object || !(0, _utils.isNumeric)(clicked.featureIndex)) {\n        return;\n      } // @ts-ignore\n\n\n      var objectType = clicked.type,\n          editHandleIndex = clicked.index; // not dragging\n\n      var updatedData = null;\n      var editType = isDragging ? _constants.EDIT_TYPE.MOVE_POSITION : _constants.EDIT_TYPE.FINISH_MOVE_POSITION;\n\n      switch (objectType) {\n        case _constants.ELEMENT_TYPE.FEATURE:\n        case _constants.ELEMENT_TYPE.FILL:\n        case _constants.ELEMENT_TYPE.SEGMENT:\n          if (!props.featuresDraggable) {\n            break;\n          } // dragging feature\n\n\n          var dx = screenCoords[0] - lastPointerMoveEvent.screenCoords[0];\n          var dy = screenCoords[1] - lastPointerMoveEvent.screenCoords[1];\n          updatedData = this._updateFeature(props, 'feature', {\n            dx: dx,\n            dy: dy\n          });\n          onEdit({\n            editType: editType,\n            updatedData: updatedData,\n            editContext: null\n          });\n          break;\n\n        case _constants.ELEMENT_TYPE.EDIT_HANDLE:\n          // dragging editHandle\n          // dragging rectangle or other shapes\n          var updateType = selectedFeature.properties.shape === _constants.SHAPE.RECTANGLE ? 'rectangle' : 'editHandle';\n          updatedData = this._updateFeature(props, updateType, {\n            editHandleIndex: editHandleIndex,\n            mapCoords: event.mapCoords\n          });\n          onEdit({\n            editType: editType,\n            updatedData: updatedData,\n            editContext: null\n          });\n          break;\n\n        default:\n      }\n    }\n  }, {\n    key: \"handlePointerMove\",\n    value: function handlePointerMove(event, props) {\n      // no selected feature\n      // @ts-ignore\n      var selectedFeature = this.getSelectedFeature(props);\n\n      if (!selectedFeature) {\n        return;\n      } // @ts-ignore\n\n\n      if (!event.isDragging) {\n        return;\n      }\n\n      this._handleDragging(event, props);\n    } // TODO - refactor\n\n  }, {\n    key: \"_updateFeature\",\n    value: function _updateFeature(props, type) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var data = props.data,\n          selectedIndexes = props.selectedIndexes,\n          viewport = props.viewport;\n      var featureIndex = selectedIndexes && selectedIndexes[0];\n      var feature = this.getSelectedFeature(props, featureIndex);\n      var geometry = null;\n      var coordinates = (0, _utils.getFeatureCoordinates)(feature);\n\n      if (!coordinates) {\n        return null;\n      }\n\n      var newCoordinates = _toConsumableArray(coordinates);\n\n      switch (type) {\n        case 'editHandle':\n          var positionIndexes = feature.geometry.type === _constants.GEOJSON_TYPE.POLYGON ? [0, options.editHandleIndex] : [options.editHandleIndex];\n          return new _editModes.ImmutableFeatureCollection(data).replacePosition(featureIndex, positionIndexes, options.mapCoords).getObject();\n\n        case 'feature':\n          var dx = options.dx,\n              dy = options.dy; // @ts-ignore\n\n          newCoordinates = newCoordinates.map(function (mapCoords) {\n            // @ts-ignore\n            var pixels = viewport && viewport.project(mapCoords);\n\n            if (pixels) {\n              pixels[0] += dx;\n              pixels[1] += dy;\n              return viewport && viewport.unproject(pixels);\n            }\n\n            return null;\n          }).filter(Boolean);\n          geometry = {\n            type: feature.geometry.type,\n            coordinates: feature.geometry.type === _constants.GEOJSON_TYPE.POLYGON ? [newCoordinates] : feature.geometry.type === _constants.GEOJSON_TYPE.POINT ? newCoordinates[0] : newCoordinates\n          };\n          return new _editModes.ImmutableFeatureCollection(data).replaceGeometry(featureIndex, geometry).getObject();\n\n        case 'rectangle':\n          // moved editHandleIndex and destination mapCoords\n          newCoordinates = (0, _utils.updateRectanglePosition)( // @ts-ignore\n          feature, options.editHandleIndex, options.mapCoords);\n          geometry = {\n            type: _constants.GEOJSON_TYPE.POLYGON,\n            coordinates: newCoordinates\n          };\n          return new _editModes.ImmutableFeatureCollection(data).replaceGeometry(featureIndex, geometry).getObject();\n\n        default:\n          return data && new _editModes.ImmutableFeatureCollection(data).getObject();\n      }\n    }\n  }, {\n    key: \"_getPointOnSegment\",\n    value: function _getPointOnSegment(feature, picked, pickedMapCoords) {\n      var coordinates = (0, _utils.getFeatureCoordinates)(feature);\n\n      if (!coordinates) {\n        return null;\n      }\n\n      var srcVertexIndex = picked.index;\n      var targetVertexIndex = picked.index + 1;\n      return (0, _utils.findClosestPointOnLineSegment)( // @ts-ignore\n      coordinates[srcVertexIndex], coordinates[targetVertexIndex], pickedMapCoords);\n    }\n  }, {\n    key: \"_getCursorEditHandle\",\n    value: function _getCursorEditHandle(event, feature) {\n      // event can be null when the user has not interacted with the map whatsoever\n      // and therefore props.lastPointerMoveEvent is still null\n      // returning null here means we can e.g. set a featureIndex without requiring an event\n      if (!event) {\n        return null;\n      } // @ts-ignore\n\n\n      var isDragging = event.isDragging,\n          picks = event.picks; // if not pick segment\n\n      var picked = picks && picks[0]; // @ts-ignore\n\n      if (!picked || !(0, _utils.isNumeric)(picked.featureIndex) || picked.type !== _constants.ELEMENT_TYPE.SEGMENT) {\n        return null;\n      } // if dragging or feature is neither polygon nor line string\n\n\n      if (isDragging || feature.geometry.type !== _constants.GEOJSON_TYPE.POLYGON && feature.geometry.type !== _constants.GEOJSON_TYPE.LINE_STRING) {\n        return null;\n      }\n\n      var insertMapCoords = this._getPointOnSegment(feature, picked, event.mapCoords);\n\n      if (!insertMapCoords) {\n        return null;\n      }\n\n      return {\n        type: 'Feature',\n        properties: {\n          guideType: _constants.GUIDE_TYPE.CURSOR_EDIT_HANDLE,\n          shape: feature.properties.shape,\n          positionIndexes: [-1],\n          editHandleType: 'intermediate'\n        },\n        geometry: {\n          type: _constants.GEOJSON_TYPE.POINT,\n          coordinates: insertMapCoords\n        }\n      };\n    } // @ts-ignore\n\n  }, {\n    key: \"getGuides\",\n    value: function getGuides(props) {\n      // @ts-ignore\n      var selectedFeature = this.getSelectedFeature(props);\n      var selectedFeatureIndex = props.selectedIndexes && props.selectedIndexes[0];\n\n      if (!selectedFeature || selectedFeature.geometry.type === _constants.GEOJSON_TYPE.POINT) {\n        return null;\n      }\n\n      var event = props.lastPointerMoveEvent; // feature editHandles\n\n      var editHandles = this.getEditHandlesFromFeature(selectedFeature, selectedFeatureIndex) || []; // cursor editHandle\n\n      var cursorEditHandle = this._getCursorEditHandle(event, selectedFeature);\n\n      if (cursorEditHandle) {\n        // @ts-ignore\n        editHandles.push(cursorEditHandle);\n      }\n\n      return {\n        type: 'FeatureCollection',\n        features: editHandles.length ? editHandles : null\n      };\n    }\n  }]);\n\n  return EditingMode;\n}(_baseMode[\"default\"]);\n\nexports[\"default\"] = EditingMode;","map":{"version":3,"sources":["../../src/edit-modes/editing-mode.ts"],"names":["EditingMode","BaseMode","event","props","picked","selectedFeatureIndex","objectType","featureIndex","index","feature","GEOJSON_TYPE","ELEMENT_TYPE","coordinates","insertIndex","positionIndexes","SHAPE","insertMapCoords","updatedData","ImmutableFeatureCollection","editType","EDIT_TYPE","editContext","editHandleIndex","screenCoords","mapCoords","pickedObject","onEdit","selectedFeature","isDragging","pointerDownPicks","lastPointerMoveEvent","clicked","dx","dy","updateType","type","options","data","selectedIndexes","viewport","geometry","newCoordinates","pixels","pickedMapCoords","srcVertexIndex","targetVertexIndex","picks","properties","guideType","GUIDE_TYPE","shape","editHandleType","editHandles","cursorEditHandle","features"],"mappings":";;;;;;;AAAA,IAAA,UAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AAWA,IAAA,UAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AACA,IAAA,SAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAOqBA,W;;;;;;;;;;;;;gCACPE,K,EAAmBC,K,EAAqC;AAClE,UAAMC,MAAM,GAAGF,KAAK,CAALA,KAAAA,IAAeA,KAAK,CAALA,KAAAA,CAA9B,CAA8BA,CAA9B;AACA,UAAMG,oBAAoB,GAAGF,KAAK,CAALA,eAAAA,IAAyBA,KAAK,CAALA,eAAAA,CAFY,CAEZA,CAAtD,CAFkE,CAGlE;;AACA,UAAI,CAAA,MAAA,IAAW,CAACC,MAAM,CAAlB,MAAA,IAA6BA,MAAM,CAANA,YAAAA,KAAjC,oBAAA,EAA+E;AAC7E;AALgE,OAAA,CAQlE;;;AARkE,UASpDE,UAToD,GAShBF,MATgB,CAAA,IAAA;AAAA,UASxCG,YATwC,GAShBH,MATgB,CAAA,YAAA;AAAA,UAS1BI,KAT0B,GAShBJ,MATgB,CAAA,KAAA;AAUlE,UAAMK,OAAO,GAAG,KAAA,kBAAA,CAAA,KAAA,EAAhB,YAAgB,CAAhB;;AAEA,UACEA,OAAO,KACNA,OAAO,CAAPA,QAAAA,CAAAA,IAAAA,KAA0BC,UAAAA,CAAAA,YAAAA,CAA1BD,OAAAA,IACCA,OAAO,CAAPA,QAAAA,CAAAA,IAAAA,KAA0BC,UAAAA,CAAAA,YAAAA,CAF5BD,WAAO,CAAPA,IAGAH,UAAU,KAAKK,UAAAA,CAAAA,YAAAA,CAJjB,OAAA,EAKE;AACA,YAAMC,WAAW,GAAG,CAAA,GAAA,MAAA,CAAA,qBAAA,EAApB,OAAoB,CAApB;;AACA,YAAI,CAAJ,WAAA,EAAkB;AAChB;AAHF,SAAA,CAKA;;;AACA,YAAMC,WAAW,GAAG,CAACL,KAAK,GAAN,CAAA,IAAcI,WAAW,CAA7C,MAAA;AACA,YAAME,eAAe,GACnBL,OAAO,CAAPA,QAAAA,CAAAA,IAAAA,KAA0BM,UAAAA,CAAAA,KAAAA,CAA1BN,OAAAA,GAA0C,CAAA,CAAA,EAA1CA,WAA0C,CAA1CA,GAA6D,CAD/D,WAC+D,CAD/D;;AAEA,YAAMO,eAAe,GAAG,KAAA,kBAAA,CAAA,OAAA,EAAA,MAAA,EAAyCd,KAAK,CAAtE,SAAwB,CAAxB;;AAEA,YAAMe,WAAW,GAAG,IAAIC,UAAAA,CAAJ,0BAAA,CAA+Bf,KAAK,CAApC,IAAA,EAClB;AADkB,SAAA,WAAA,CAAA,YAAA,EAAA,eAAA,EAAA,eAAA,EAApB,SAAoB,EAApB;AAKAA,QAAAA,KAAK,CAALA,MAAAA,CAAa;AACXgB,UAAAA,QAAQ,EAAEC,UAAAA,CAAAA,SAAAA,CADC,YAAA;AAEXH,UAAAA,WAAW,EAFA,WAAA;AAGXI,UAAAA,WAAW,EAAE,CACX;AACEd,YAAAA,YAAY,EADd,YAAA;AAEEe,YAAAA,eAAe,EAFjB,WAAA;AAGE;AACAC,YAAAA,YAAY,EAAEpB,KAAK,CAALA,QAAAA,IAAkBA,KAAK,CAALA,QAAAA,CAAAA,OAAAA,CAJlC,eAIkCA,CAJlC;AAKEqB,YAAAA,SAAS,EAAER;AALb,WADW;AAHF,SAAbb;AAaD;AACF;;;uCAEkBD,K,EAA0BC,K,EAAqC;AAChF;AACA,UAAMC,MAAM,GAAGF,KAAK,CAALA,KAAAA,IAAeA,KAAK,CAALA,KAAAA,CAFkD,CAElDA,CAA9B,CAFgF,CAIhF;;AACA,UAAI,CAAA,MAAA,IAAW,CAACE,MAAM,CAAlB,MAAA,IAA6B,CAAC,CAAA,GAAA,MAAA,CAAA,SAAA,EAAUA,MAAM,CAAlD,YAAkC,CAAlC,EAAkE;AAChE;AACD;;AAED,UAAMqB,YAAY,GAAGrB,MAAM,CAA3B,MAAA;;AACA,cAAQqB,YAAY,CAApB,IAAA;AACE,aAAKd,UAAAA,CAAAA,YAAAA,CAAL,OAAA;AACA,aAAKA,UAAAA,CAAAA,YAAAA,CAAL,IAAA;AACA,aAAKA,UAAAA,CAAAA,YAAAA,CAAL,WAAA;AACE,eAAA,eAAA,CAAA,KAAA,EAAA,KAAA;;AAEA;;AACF;AAPF;AASD;;;oCAGCT,K,EACAC,K,EACA;AAAA,UACQuB,MADR,GACmBvB,KADnB,CAAA,MAAA,CAAA,CAEA;;AACA,UAAMwB,eAAe,GAAG,KAAA,kBAAA,CAHxB,KAGwB,CAAxB,CAHA,CAIA;AACA;;AALA,UAMQC,UANR,GAMuD1B,KANvD,CAAA,UAAA;AAAA,UAMoB2B,gBANpB,GAMuD3B,KANvD,CAAA,gBAAA;AAAA,UAMsCqB,YANtC,GAMuDrB,KANvD,CAAA,YAAA;AAAA,UAOQ4B,oBAPR,GAOiC3B,KAPjC,CAAA,oBAAA;AASA,UAAM4B,OAAO,GAAGF,gBAAgB,IAAIA,gBAAgB,CATpD,CASoD,CAApD,CATA,CAUA;;AACA,UAAI,CAAA,OAAA,IAAY,CAACE,OAAO,CAApB,MAAA,IAA+B,CAAC,CAAA,GAAA,MAAA,CAAA,SAAA,EAAUA,OAAO,CAArD,YAAoC,CAApC,EAAqE;AACnE;AAZF,OAAA,CAeA;;;AAfA,UAgBczB,UAhBd,GAgBqDyB,OAhBrD,CAAA,IAAA;AAAA,UAgBiCT,eAhBjC,GAgBqDS,OAhBrD,CAAA,KAAA,CAAA,CAkBA;;AACA,UAAId,WAAW,GAAf,IAAA;AACA,UAAME,QAAQ,GAAGS,UAAU,GAAGR,UAAAA,CAAAA,SAAAA,CAAH,aAAA,GAA6BA,UAAAA,CAAAA,SAAAA,CAAxD,oBAAA;;AAEA,cAAA,UAAA;AACE,aAAKT,UAAAA,CAAAA,YAAAA,CAAL,OAAA;AACA,aAAKA,UAAAA,CAAAA,YAAAA,CAAL,IAAA;AACA,aAAKA,UAAAA,CAAAA,YAAAA,CAAL,OAAA;AACE,cAAI,CAACR,KAAK,CAAV,iBAAA,EAA8B;AAC5B;AAFJ,WAAA,CAGI;;;AAEF,cAAM6B,EAAE,GAAGT,YAAY,CAAZA,CAAY,CAAZA,GAAkBO,oBAAoB,CAApBA,YAAAA,CAA7B,CAA6BA,CAA7B;AACA,cAAMG,EAAE,GAAGV,YAAY,CAAZA,CAAY,CAAZA,GAAkBO,oBAAoB,CAApBA,YAAAA,CAA7B,CAA6BA,CAA7B;AACAb,UAAAA,WAAW,GAAG,KAAA,cAAA,CAAA,KAAA,EAAA,SAAA,EAAsC;AAAEe,YAAAA,EAAE,EAAJ,EAAA;AAAMC,YAAAA,EAAE,EAAFA;AAAN,WAAtC,CAAdhB;AACAS,UAAAA,MAAM,CAAC;AACLP,YAAAA,QAAQ,EADH,QAAA;AAELF,YAAAA,WAAW,EAFN,WAAA;AAGLI,YAAAA,WAAW,EAAE;AAHR,WAAD,CAANK;AAKA;;AAEF,aAAKf,UAAAA,CAAAA,YAAAA,CAAL,WAAA;AACE;AACA;AACA,cAAMuB,UAAU,GACdP,eAAe,CAAfA,UAAAA,CAAAA,KAAAA,KAAqCZ,UAAAA,CAAAA,KAAAA,CAArCY,SAAAA,GAAAA,WAAAA,GADF,YAAA;AAEAV,UAAAA,WAAW,GAAG,KAAA,cAAA,CAAA,KAAA,EAAA,UAAA,EAAuC;AACnDK,YAAAA,eAAe,EADoC,eAAA;AAEnDE,YAAAA,SAAS,EAAEtB,KAAK,CAACsB;AAFkC,WAAvC,CAAdP;AAIAS,UAAAA,MAAM,CAAC;AACLP,YAAAA,QAAQ,EADH,QAAA;AAELF,YAAAA,WAAW,EAFN,WAAA;AAGLI,YAAAA,WAAW,EAAE;AAHR,WAAD,CAANK;AAKA;;AAEF;AAlCF;AAoCD;;;sCAEiBxB,K,EAAyBC,K,EAAqC;AAC9E;AACA;AACA,UAAMwB,eAAe,GAAG,KAAA,kBAAA,CAAxB,KAAwB,CAAxB;;AACA,UAAI,CAAJ,eAAA,EAAsB;AACpB;AAL4E,OAAA,CAO9E;;;AACA,UAAI,CAACzB,KAAK,CAAV,UAAA,EAAuB;AACrB;AACD;;AAED,WAAA,eAAA,CAAA,KAAA,EAAA,KAAA;MAGF;;;;mCACeC,K,EAAqCgC,I,EAAiC;AAAA,UAAnBC,OAAmB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,EAAI;AAAA,UAC3EC,IAD2E,GACvClC,KADuC,CAAA,IAAA;AAAA,UACrEmC,eADqE,GACvCnC,KADuC,CAAA,eAAA;AAAA,UACpDoC,QADoD,GACvCpC,KADuC,CAAA,QAAA;AAGnF,UAAMI,YAAY,GAAG+B,eAAe,IAAIA,eAAe,CAAvD,CAAuD,CAAvD;AACA,UAAM7B,OAAO,GAAG,KAAA,kBAAA,CAAA,KAAA,EAAhB,YAAgB,CAAhB;AAEA,UAAI+B,QAAQ,GAAZ,IAAA;AACA,UAAM5B,WAAW,GAAG,CAAA,GAAA,MAAA,CAAA,qBAAA,EAApB,OAAoB,CAApB;;AACA,UAAI,CAAJ,WAAA,EAAkB;AAChB,eAAA,IAAA;AACD;;AAED,UAAI6B,cAAc,GAAA,kBAAA,CAAlB,WAAkB,CAAlB;;AAEA,cAAA,IAAA;AACE,aAAA,YAAA;AACE,cAAM3B,eAAe,GACnBL,OAAO,CAAPA,QAAAA,CAAAA,IAAAA,KAA0BC,UAAAA,CAAAA,YAAAA,CAA1BD,OAAAA,GACI,CAAA,CAAA,EAAI2B,OAAO,CADf3B,eACI,CADJA,GAEI,CAAC2B,OAAO,CAHd,eAGM,CAHN;AAKA,iBAAO,IAAIlB,UAAAA,CAAJ,0BAAA,CAAA,IAAA,EAAA,eAAA,CAAA,YAAA,EAAA,eAAA,EAC2CkB,OAAO,CADlD,SAAA,EAAP,SAAO,EAAP;;AAIF,aAAA,SAAA;AAAA,cACUJ,EADV,GACqBI,OADrB,CAAA,EAAA;AAAA,cACcH,EADd,GACqBG,OADrB,CAAA,EAAA,CAAA,CAGE;;AACAK,UAAAA,cAAc,GAAG,cAAc,CAAd,GAAA,CACV,UAAA,SAAA,EAAe;AAClB;AACA,gBAAMC,MAAM,GAAGH,QAAQ,IAAIA,QAAQ,CAARA,OAAAA,CAA3B,SAA2BA,CAA3B;;AACA,gBAAA,MAAA,EAAY;AACVG,cAAAA,MAAM,CAANA,CAAM,CAANA,IAAAA,EAAAA;AACAA,cAAAA,MAAM,CAANA,CAAM,CAANA,IAAAA,EAAAA;AACA,qBAAOH,QAAQ,IAAIA,QAAQ,CAARA,SAAAA,CAAnB,MAAmBA,CAAnB;AACD;;AACD,mBAAA,IAAA;AATa,WAAA,EAAA,MAAA,CAAjBE,OAAiB,CAAjBA;AAYAD,UAAAA,QAAQ,GAAG;AACTL,YAAAA,IAAI,EAAE1B,OAAO,CAAPA,QAAAA,CADG,IAAA;AAETG,YAAAA,WAAW,EACTH,OAAO,CAAPA,QAAAA,CAAAA,IAAAA,KAA0BC,UAAAA,CAAAA,YAAAA,CAA1BD,OAAAA,GACI,CADJA,cACI,CADJA,GAEIA,OAAO,CAAPA,QAAAA,CAAAA,IAAAA,KAA0BC,UAAAA,CAAAA,YAAAA,CAA1BD,KAAAA,GACAgC,cAAc,CADdhC,CACc,CADdA,GAEAgC;AAPG,WAAXD;AAUA,iBAAO,IAAItB,UAAAA,CAAJ,0BAAA,CAAA,IAAA,EAAA,eAAA,CAAA,YAAA,EAAA,QAAA,EAAP,SAAO,EAAP;;AAIF,aAAA,WAAA;AACE;AACAuB,UAAAA,cAAc,GAAG,CAAA,GAAA,MAAA,CAAA,uBAAA,GACf;AADe,UAAA,OAAA,EAGfL,OAAO,CAHQ,eAAA,EAIfA,OAAO,CAJTK,SAAiB,CAAjBA;AAMAD,UAAAA,QAAQ,GAAG;AACTL,YAAAA,IAAI,EAAEzB,UAAAA,CAAAA,YAAAA,CADG,OAAA;AAETE,YAAAA,WAAW,EAAE6B;AAFJ,WAAXD;AAKA,iBAAO,IAAItB,UAAAA,CAAJ,0BAAA,CAAA,IAAA,EAAA,eAAA,CAAA,YAAA,EAAA,QAAA,EAAP,SAAO,EAAP;;AAIF;AACE,iBAAOmB,IAAI,IAAI,IAAInB,UAAAA,CAAJ,0BAAA,CAAA,IAAA,EAAf,SAAe,EAAf;AA3DJ;AA6DD;;;uCAEkBT,O,EAAkBL,M,EAAauC,e,EAA2B;AAC3E,UAAM/B,WAAW,GAAG,CAAA,GAAA,MAAA,CAAA,qBAAA,EAApB,OAAoB,CAApB;;AACA,UAAI,CAAJ,WAAA,EAAkB;AAChB,eAAA,IAAA;AACD;;AACD,UAAMgC,cAAc,GAAGxC,MAAM,CAA7B,KAAA;AACA,UAAMyC,iBAAiB,GAAGzC,MAAM,CAANA,KAAAA,GAA1B,CAAA;AACA,aAAO,CAAA,GAAA,MAAA,CAAA,6BAAA,GACL;AACAQ,MAAAA,WAAW,CAFN,cAEM,CAFN,EAGLA,WAAW,CAHN,iBAGM,CAHN,EAAP,eAAO,CAAP;AAMD;;;yCAEoBV,K,EAAyBO,O,EAAkB;AAC9D;AACA;AACA;AACA,UAAI,CAAJ,KAAA,EAAY;AACV,eAAA,IAAA;AAL4D,OAAA,CAQ9D;;;AAR8D,UAStDmB,UATsD,GAShC1B,KATgC,CAAA,UAAA;AAAA,UAS1C4C,KAT0C,GAShC5C,KATgC,CAAA,KAAA,CAAA,CAU9D;;AACA,UAAME,MAAM,GAAG0C,KAAK,IAAIA,KAAK,CAXiC,CAWjC,CAA7B,CAX8D,CAY9D;;AACA,UAAI,CAAA,MAAA,IAAW,CAAC,CAAA,GAAA,MAAA,CAAA,SAAA,EAAU1C,MAAM,CAA5B,YAAY,CAAZ,IAA8CA,MAAM,CAANA,IAAAA,KAAgBO,UAAAA,CAAAA,YAAAA,CAAlE,OAAA,EAAwF;AACtF,eAAA,IAAA;AAd4D,OAAA,CAiB9D;;;AACA,UACEiB,UAAU,IACTnB,OAAO,CAAPA,QAAAA,CAAAA,IAAAA,KAA0BC,UAAAA,CAAAA,YAAAA,CAA1BD,OAAAA,IACCA,OAAO,CAAPA,QAAAA,CAAAA,IAAAA,KAA0BC,UAAAA,CAAAA,YAAAA,CAH9B,WAAA,EAIE;AACA,eAAA,IAAA;AACD;;AAED,UAAMM,eAAe,GAAG,KAAA,kBAAA,CAAA,OAAA,EAAA,MAAA,EAAyCd,KAAK,CAAtE,SAAwB,CAAxB;;AAEA,UAAI,CAAJ,eAAA,EAAsB;AACpB,eAAA,IAAA;AACD;;AAED,aAAO;AACLiC,QAAAA,IAAI,EADC,SAAA;AAELY,QAAAA,UAAU,EAAE;AACVC,UAAAA,SAAS,EAAEC,UAAAA,CAAAA,UAAAA,CADD,kBAAA;AAEVC,UAAAA,KAAK,EAAEzC,OAAO,CAAPA,UAAAA,CAFG,KAAA;AAGVK,UAAAA,eAAe,EAAE,CAAC,CAHR,CAGO,CAHP;AAIVqC,UAAAA,cAAc,EAAE;AAJN,SAFP;AAQLX,QAAAA,QAAQ,EAAE;AACRL,UAAAA,IAAI,EAAEzB,UAAAA,CAAAA,YAAAA,CADE,KAAA;AAERE,UAAAA,WAAW,EAAEI;AAFL;AARL,OAAP;MAcF;;;;8BACUb,K,EAAqC;AAC7C;AACA,UAAMwB,eAAe,GAAG,KAAA,kBAAA,CAAxB,KAAwB,CAAxB;AACA,UAAMtB,oBAAoB,GAAGF,KAAK,CAALA,eAAAA,IAAyBA,KAAK,CAALA,eAAAA,CAAtD,CAAsDA,CAAtD;;AAEA,UAAI,CAAA,eAAA,IAAoBwB,eAAe,CAAfA,QAAAA,CAAAA,IAAAA,KAAkCjB,UAAAA,CAAAA,YAAAA,CAA1D,KAAA,EAA8E;AAC5E,eAAA,IAAA;AACD;;AAED,UAAMR,KAAK,GAAGC,KAAK,CAT0B,oBAS7C,CAT6C,CAW7C;;AACA,UAAMiD,WAAW,GAAG,KAAA,yBAAA,CAAA,eAAA,EAAA,oBAAA,KAZyB,EAY7C,CAZ6C,CAc7C;;AACA,UAAMC,gBAAgB,GAAG,KAAA,oBAAA,CAAA,KAAA,EAAzB,eAAyB,CAAzB;;AACA,UAAA,gBAAA,EAAsB;AACpB;AACAD,QAAAA,WAAW,CAAXA,IAAAA,CAAAA,gBAAAA;AACD;;AAED,aAAO;AACLjB,QAAAA,IAAI,EADC,mBAAA;AAELmB,QAAAA,QAAQ,EAAEF,WAAW,CAAXA,MAAAA,GAAAA,WAAAA,GAAmC;AAFxC,OAAP;AAID;;;;EA1TsCnD,SAAAA,CAAAA,SAAAA,C","sourcesContent":["import { ImmutableFeatureCollection } from '@nebula.gl/edit-modes';\nimport type {\n  Feature,\n  FeatureCollection,\n  ClickEvent,\n  StopDraggingEvent,\n  PointerMoveEvent,\n  Position,\n} from '@nebula.gl/edit-modes';\nimport { ModeProps } from '../types';\n\nimport { SHAPE, EDIT_TYPE, ELEMENT_TYPE, GEOJSON_TYPE, GUIDE_TYPE } from '../constants';\nimport BaseMode from './base-mode';\nimport {\n  findClosestPointOnLineSegment,\n  getFeatureCoordinates,\n  isNumeric,\n  updateRectanglePosition,\n} from './utils';\n\nexport default class EditingMode extends BaseMode {\n  handleClick(event: ClickEvent, props: ModeProps<FeatureCollection>) {\n    const picked = event.picks && event.picks[0];\n    const selectedFeatureIndex = props.selectedIndexes && props.selectedIndexes[0];\n    // @ts-ignore\n    if (!picked || !picked.object || picked.featureIndex !== selectedFeatureIndex) {\n      return;\n    }\n\n    // @ts-ignore\n    const { type: objectType, featureIndex, index } = picked;\n    const feature = this.getSelectedFeature(props, featureIndex);\n\n    if (\n      feature &&\n      (feature.geometry.type === GEOJSON_TYPE.POLYGON ||\n        feature.geometry.type === GEOJSON_TYPE.LINE_STRING) &&\n      objectType === ELEMENT_TYPE.SEGMENT\n    ) {\n      const coordinates = getFeatureCoordinates(feature);\n      if (!coordinates) {\n        return;\n      }\n      // @ts-ignore\n      const insertIndex = (index + 1) % coordinates.length;\n      const positionIndexes =\n        feature.geometry.type === SHAPE.POLYGON ? [0, insertIndex] : [insertIndex];\n      const insertMapCoords = this._getPointOnSegment(feature, picked, event.mapCoords);\n\n      const updatedData = new ImmutableFeatureCollection(props.data)\n        // @ts-ignore\n        .addPosition(featureIndex, positionIndexes, insertMapCoords)\n        .getObject();\n\n      props.onEdit({\n        editType: EDIT_TYPE.ADD_POSITION,\n        updatedData,\n        editContext: [\n          {\n            featureIndex,\n            editHandleIndex: insertIndex,\n            // @ts-ignore\n            screenCoords: props.viewport && props.viewport.project(insertMapCoords),\n            mapCoords: insertMapCoords,\n          },\n        ],\n      });\n    }\n  }\n\n  handleStopDragging(event: StopDraggingEvent, props: ModeProps<FeatureCollection>) {\n    // replace point\n    const picked = event.picks && event.picks[0];\n\n    // @ts-ignore\n    if (!picked || !picked.Object || !isNumeric(picked.featureIndex)) {\n      return;\n    }\n\n    const pickedObject = picked.object;\n    switch (pickedObject.type) {\n      case ELEMENT_TYPE.FEATURE:\n      case ELEMENT_TYPE.FILL:\n      case ELEMENT_TYPE.EDIT_HANDLE:\n        this._handleDragging(event, props);\n\n        break;\n      default:\n    }\n  }\n\n  _handleDragging(\n    event: PointerMoveEvent | StopDraggingEvent,\n    props: ModeProps<FeatureCollection>\n  ) {\n    const { onEdit } = props;\n    // @ts-ignore\n    const selectedFeature = this.getSelectedFeature(props);\n    // nothing clicked\n    // @ts-ignore\n    const { isDragging, pointerDownPicks, screenCoords } = event;\n    const { lastPointerMoveEvent } = props;\n\n    const clicked = pointerDownPicks && pointerDownPicks[0];\n    // @ts-ignore\n    if (!clicked || !clicked.object || !isNumeric(clicked.featureIndex)) {\n      return;\n    }\n\n    // @ts-ignore\n    const { type: objectType, index: editHandleIndex } = clicked;\n\n    // not dragging\n    let updatedData = null;\n    const editType = isDragging ? EDIT_TYPE.MOVE_POSITION : EDIT_TYPE.FINISH_MOVE_POSITION;\n\n    switch (objectType) {\n      case ELEMENT_TYPE.FEATURE:\n      case ELEMENT_TYPE.FILL:\n      case ELEMENT_TYPE.SEGMENT:\n        if (!props.featuresDraggable) {\n          break;\n        } // dragging feature\n\n        const dx = screenCoords[0] - lastPointerMoveEvent.screenCoords[0];\n        const dy = screenCoords[1] - lastPointerMoveEvent.screenCoords[1];\n        updatedData = this._updateFeature(props, 'feature', { dx, dy });\n        onEdit({\n          editType,\n          updatedData,\n          editContext: null,\n        });\n        break;\n\n      case ELEMENT_TYPE.EDIT_HANDLE:\n        // dragging editHandle\n        // dragging rectangle or other shapes\n        const updateType =\n          selectedFeature.properties.shape === SHAPE.RECTANGLE ? 'rectangle' : 'editHandle';\n        updatedData = this._updateFeature(props, updateType, {\n          editHandleIndex,\n          mapCoords: event.mapCoords,\n        });\n        onEdit({\n          editType,\n          updatedData,\n          editContext: null,\n        });\n        break;\n\n      default:\n    }\n  }\n\n  handlePointerMove(event: PointerMoveEvent, props: ModeProps<FeatureCollection>) {\n    // no selected feature\n    // @ts-ignore\n    const selectedFeature = this.getSelectedFeature(props);\n    if (!selectedFeature) {\n      return;\n    }\n    // @ts-ignore\n    if (!event.isDragging) {\n      return;\n    }\n\n    this._handleDragging(event, props);\n  }\n\n  // TODO - refactor\n  _updateFeature(props: ModeProps<FeatureCollection>, type: string, options: any = {}) {\n    const { data, selectedIndexes, viewport } = props;\n\n    const featureIndex = selectedIndexes && selectedIndexes[0];\n    const feature = this.getSelectedFeature(props, featureIndex);\n\n    let geometry = null;\n    const coordinates = getFeatureCoordinates(feature);\n    if (!coordinates) {\n      return null;\n    }\n\n    let newCoordinates = [...coordinates];\n\n    switch (type) {\n      case 'editHandle':\n        const positionIndexes =\n          feature.geometry.type === GEOJSON_TYPE.POLYGON\n            ? [0, options.editHandleIndex]\n            : [options.editHandleIndex];\n\n        return new ImmutableFeatureCollection(data)\n          .replacePosition(featureIndex, positionIndexes, options.mapCoords)\n          .getObject();\n\n      case 'feature':\n        const { dx, dy } = options;\n\n        // @ts-ignore\n        newCoordinates = newCoordinates\n          .map((mapCoords) => {\n            // @ts-ignore\n            const pixels = viewport && viewport.project(mapCoords);\n            if (pixels) {\n              pixels[0] += dx;\n              pixels[1] += dy;\n              return viewport && viewport.unproject(pixels);\n            }\n            return null;\n          })\n          .filter(Boolean);\n        geometry = {\n          type: feature.geometry.type,\n          coordinates:\n            feature.geometry.type === GEOJSON_TYPE.POLYGON\n              ? [newCoordinates]\n              : feature.geometry.type === GEOJSON_TYPE.POINT\n              ? newCoordinates[0]\n              : newCoordinates,\n        };\n\n        return new ImmutableFeatureCollection(data)\n          .replaceGeometry(featureIndex, geometry)\n          .getObject();\n\n      case 'rectangle':\n        // moved editHandleIndex and destination mapCoords\n        newCoordinates = updateRectanglePosition(\n          // @ts-ignore\n          feature,\n          options.editHandleIndex,\n          options.mapCoords\n        );\n        geometry = {\n          type: GEOJSON_TYPE.POLYGON,\n          coordinates: newCoordinates,\n        };\n\n        return new ImmutableFeatureCollection(data)\n          .replaceGeometry(featureIndex, geometry)\n          .getObject();\n\n      default:\n        return data && new ImmutableFeatureCollection(data).getObject();\n    }\n  }\n\n  _getPointOnSegment(feature: Feature, picked: any, pickedMapCoords: Position) {\n    const coordinates = getFeatureCoordinates(feature);\n    if (!coordinates) {\n      return null;\n    }\n    const srcVertexIndex = picked.index;\n    const targetVertexIndex = picked.index + 1;\n    return findClosestPointOnLineSegment(\n      // @ts-ignore\n      coordinates[srcVertexIndex],\n      coordinates[targetVertexIndex],\n      pickedMapCoords\n    );\n  }\n\n  _getCursorEditHandle(event: PointerMoveEvent, feature: Feature) {\n    // event can be null when the user has not interacted with the map whatsoever\n    // and therefore props.lastPointerMoveEvent is still null\n    // returning null here means we can e.g. set a featureIndex without requiring an event\n    if (!event) {\n      return null;\n    }\n\n    // @ts-ignore\n    const { isDragging, picks } = event;\n    // if not pick segment\n    const picked = picks && picks[0];\n    // @ts-ignore\n    if (!picked || !isNumeric(picked.featureIndex) || picked.type !== ELEMENT_TYPE.SEGMENT) {\n      return null;\n    }\n\n    // if dragging or feature is neither polygon nor line string\n    if (\n      isDragging ||\n      (feature.geometry.type !== GEOJSON_TYPE.POLYGON &&\n        feature.geometry.type !== GEOJSON_TYPE.LINE_STRING)\n    ) {\n      return null;\n    }\n\n    const insertMapCoords = this._getPointOnSegment(feature, picked, event.mapCoords);\n\n    if (!insertMapCoords) {\n      return null;\n    }\n\n    return {\n      type: 'Feature',\n      properties: {\n        guideType: GUIDE_TYPE.CURSOR_EDIT_HANDLE,\n        shape: feature.properties.shape,\n        positionIndexes: [-1],\n        editHandleType: 'intermediate',\n      },\n      geometry: {\n        type: GEOJSON_TYPE.POINT,\n        coordinates: insertMapCoords,\n      },\n    };\n  }\n  // @ts-ignore\n  getGuides(props: ModeProps<FeatureCollection>) {\n    // @ts-ignore\n    const selectedFeature = this.getSelectedFeature(props);\n    const selectedFeatureIndex = props.selectedIndexes && props.selectedIndexes[0];\n\n    if (!selectedFeature || selectedFeature.geometry.type === GEOJSON_TYPE.POINT) {\n      return null;\n    }\n\n    const event = props.lastPointerMoveEvent;\n\n    // feature editHandles\n    const editHandles = this.getEditHandlesFromFeature(selectedFeature, selectedFeatureIndex) || [];\n\n    // cursor editHandle\n    const cursorEditHandle = this._getCursorEditHandle(event, selectedFeature);\n    if (cursorEditHandle) {\n      // @ts-ignore\n      editHandles.push(cursorEditHandle);\n    }\n\n    return {\n      type: 'FeatureCollection',\n      features: editHandles.length ? editHandles : null,\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"script"}