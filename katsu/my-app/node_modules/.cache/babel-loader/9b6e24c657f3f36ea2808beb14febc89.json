{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isNumeric = isNumeric;\nexports.parseEventElement = parseEventElement;\nexports.getScreenCoords = getScreenCoords;\nexports.findClosestPointOnLineSegment = findClosestPointOnLineSegment;\nexports.getFeatureCoordinates = getFeatureCoordinates;\nexports.updateRectanglePosition = updateRectanglePosition;\n\nvar _constants = require(\"../constants\");\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction isNumeric(val) {\n  return !Array.isArray(val) && !isNaN(parseFloat(val)) && isFinite(val);\n}\n\nfunction parseEventElement(evt, features, guides) {\n  var elem = evt.target;\n\n  if (!elem || !elem.dataset || !elem.dataset.type) {\n    return null;\n  }\n\n  var featureIndex = elem.dataset.featureIndex;\n  featureIndex = isNumeric(featureIndex) ? Number(featureIndex) : -1;\n  var index = elem.dataset.index;\n  index = isNumeric(index) ? Number(index) : undefined;\n  var type = elem.dataset.type;\n  var tentativeFeature = guides && guides.find(function (g) {\n    return g.properties.guideType === _constants.GUIDE_TYPE.TENTATIVE;\n  });\n  var object = null;\n  var isGuide = false;\n\n  switch (type) {\n    case _constants.ELEMENT_TYPE.EDIT_HANDLE:\n      object = guides.find(function (g) {\n        var indexes = g.properties.positionIndexes;\n\n        if (indexes) {\n          return indexes[indexes.length - 1] === index;\n        }\n\n        return false;\n      });\n      isGuide = true;\n      break;\n\n    case _constants.ELEMENT_TYPE.SEGMENT:\n    case _constants.ELEMENT_TYPE.FEATURE:\n    case _constants.ELEMENT_TYPE.FILL:\n      object = features[featureIndex] || tentativeFeature;\n      break;\n\n    default:\n  }\n\n  return {\n    object: object,\n    isGuide: isGuide,\n    type: type,\n    index: index,\n    featureIndex: featureIndex\n  };\n}\n\nfunction getScreenCoords(evt) {\n  var _evt$offsetCenter = evt.offsetCenter,\n      x = _evt$offsetCenter.x,\n      y = _evt$offsetCenter.y;\n  return [Number(x), Number(y)];\n}\n\nfunction findClosestPointOnLineSegment(p1, p2, p) {\n  // line\n  var k = (p2[1] - p1[1]) / (p2[0] - p1[0]);\n  var b = p1[1] - k * p1[0]; // vertical line\n\n  if (!isFinite(k)) {\n    var q = [p1[0], p[1]];\n    return inBounds(p1, p2, q) ? q : null;\n  } // p is on line [p1, p2]\n\n\n  if (p[0] * k + b - p[1] === 0) {\n    return inBounds(p1, p2, p) ? p : null;\n  }\n\n  var qx = (k * p[1] + p[0] - k * b) / (k * k + 1);\n  var qy = k * qx + b;\n  return inBounds(p1, p2, [qx, qy]) ? [qx, qy] : null;\n}\n\nfunction getFeatureCoordinates(feature) {\n  var coordinates = feature && feature.geometry && feature.geometry.coordinates;\n\n  if (!coordinates) {\n    return null;\n  }\n\n  var isPolygonal = feature.geometry.type === _constants.GEOJSON_TYPE.POLYGON;\n  var isSinglePoint = feature.geometry.type === _constants.GEOJSON_TYPE.POINT;\n  return isPolygonal ? coordinates[0] : isSinglePoint ? [coordinates] : coordinates;\n}\n\nfunction updateRectanglePosition(feature, editHandleIndex, mapCoords) {\n  var coordinates = getFeatureCoordinates(feature);\n\n  if (!coordinates) {\n    return null;\n  } // @ts-ignore\n\n\n  var points = coordinates.slice(0, 4);\n  points[editHandleIndex % 4] = mapCoords;\n  /*\n   *   p0.x, p0.y (p0) ------ p2.x, p0.y (p1)\n   *       |                      |\n   *       |                      |\n   *   p0.x, p2.y (p3) ----- p2.x, p2.y (p2)\n   */\n\n  var p0 = points[(editHandleIndex + 2) % 4];\n  var p2 = points[editHandleIndex % 4];\n  points[(editHandleIndex + 1) % 4] = [p2[0], p0[1]];\n  points[(editHandleIndex + 3) % 4] = [p0[0], p2[1]];\n  return feature.geometry.type === _constants.GEOJSON_TYPE.POLYGON ? [[].concat(_toConsumableArray(points), [points[0]])] : points;\n}\n\nfunction inBounds(p1, p2, p) {\n  var bounds = [Math.min(p1[0], p2[0]), Math.max(p1[0], p2[0]), Math.min(p1[1], p2[1]), Math.max(p1[1], p2[1])];\n  return p[0] >= bounds[0] && p[0] <= bounds[1] && p[1] >= bounds[2] && p[1] <= bounds[3];\n}","map":{"version":3,"sources":["../../src/edit-modes/utils.ts"],"names":["Array","isNaN","parseFloat","isFinite","elem","evt","featureIndex","isNumeric","Number","index","type","tentativeFeature","guides","g","GUIDE_TYPE","object","isGuide","ELEMENT_TYPE","indexes","features","x","y","k","p2","p1","b","q","p","inBounds","qx","qy","coordinates","feature","isPolygonal","GEOJSON_TYPE","isSinglePoint","getFeatureCoordinates","points","editHandleIndex","p0","bounds","Math"],"mappings":"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","sourcesContent":["import { MjolnirEvent } from 'mjolnir.js';\nimport type { FeatureOf, Feature, Polygon, Position } from '@nebula.gl/edit-modes';\n\nimport { GEOJSON_TYPE, ELEMENT_TYPE, GUIDE_TYPE } from '../constants';\n\nexport function isNumeric(val: any) {\n  return !Array.isArray(val) && !isNaN(parseFloat(val)) && isFinite(val);\n}\n\nexport function parseEventElement(evt: MjolnirEvent, features: Feature[], guides: Feature[]) {\n  const elem = evt.target;\n  if (!elem || !elem.dataset || !elem.dataset.type) {\n    return null;\n  }\n\n  let featureIndex = elem.dataset.featureIndex;\n  featureIndex = isNumeric(featureIndex) ? Number(featureIndex) : -1;\n\n  let index = elem.dataset.index;\n  index = isNumeric(index) ? Number(index) : undefined;\n\n  const type = elem.dataset.type;\n  const tentativeFeature =\n    guides && guides.find((g) => g.properties.guideType === GUIDE_TYPE.TENTATIVE);\n  let object = null;\n  let isGuide = false;\n\n  switch (type) {\n    case ELEMENT_TYPE.EDIT_HANDLE:\n      object = guides.find((g) => {\n        const indexes = g.properties.positionIndexes;\n        if (indexes) {\n          return indexes[indexes.length - 1] === index;\n        }\n        return false;\n      });\n      isGuide = true;\n      break;\n    case ELEMENT_TYPE.SEGMENT:\n    case ELEMENT_TYPE.FEATURE:\n    case ELEMENT_TYPE.FILL:\n      object = features[featureIndex] || tentativeFeature;\n      break;\n    default:\n  }\n\n  return {\n    object,\n    isGuide,\n    type,\n    index,\n    featureIndex,\n  };\n}\n\nexport function getScreenCoords(evt: MjolnirEvent) {\n  const {\n    offsetCenter: { x, y },\n  } = evt;\n  return [Number(x), Number(y)];\n}\n\nexport function findClosestPointOnLineSegment(p1: Position, p2: Position, p: Position) {\n  // line\n  const k = (p2[1] - p1[1]) / (p2[0] - p1[0]);\n  const b = p1[1] - k * p1[0];\n\n  // vertical line\n  if (!isFinite(k)) {\n    const q: Position = [p1[0], p[1]];\n    return inBounds(p1, p2, q) ? q : null;\n  }\n\n  // p is on line [p1, p2]\n  if (p[0] * k + b - p[1] === 0) {\n    return inBounds(p1, p2, p) ? p : null;\n  }\n\n  const qx = (k * p[1] + p[0] - k * b) / (k * k + 1);\n  const qy = k * qx + b;\n\n  return inBounds(p1, p2, [qx, qy]) ? [qx, qy] : null;\n}\n\nexport function getFeatureCoordinates(feature: Feature) {\n  const coordinates = feature && feature.geometry && feature.geometry.coordinates;\n  if (!coordinates) {\n    return null;\n  }\n\n  const isPolygonal = feature.geometry.type === GEOJSON_TYPE.POLYGON;\n  const isSinglePoint = feature.geometry.type === GEOJSON_TYPE.POINT;\n  return isPolygonal ? coordinates[0] : isSinglePoint ? [coordinates] : coordinates;\n}\n\nexport function updateRectanglePosition(\n  feature: FeatureOf<Polygon>,\n  editHandleIndex: number,\n  mapCoords: Position\n) {\n  const coordinates = getFeatureCoordinates(feature);\n  if (!coordinates) {\n    return null;\n  }\n  // @ts-ignore\n  const points = coordinates.slice(0, 4);\n  points[editHandleIndex % 4] = mapCoords;\n\n  /*\n   *   p0.x, p0.y (p0) ------ p2.x, p0.y (p1)\n   *       |                      |\n   *       |                      |\n   *   p0.x, p2.y (p3) ----- p2.x, p2.y (p2)\n   */\n  const p0 = points[(editHandleIndex + 2) % 4];\n  const p2 = points[editHandleIndex % 4];\n  points[(editHandleIndex + 1) % 4] = [p2[0], p0[1]];\n  points[(editHandleIndex + 3) % 4] = [p0[0], p2[1]];\n\n  return feature.geometry.type === GEOJSON_TYPE.POLYGON ? [[...points, points[0]]] : points;\n}\n\nfunction inBounds(p1: Position, p2: Position, p: Position): boolean {\n  const bounds = [\n    Math.min(p1[0], p2[0]),\n    Math.max(p1[0], p2[0]),\n    Math.min(p1[1], p2[1]),\n    Math.max(p1[1], p2[1]),\n  ];\n\n  return p[0] >= bounds[0] && p[0] <= bounds[1] && p[1] >= bounds[2] && p[1] <= bounds[3];\n}\n"]},"metadata":{},"sourceType":"script"}